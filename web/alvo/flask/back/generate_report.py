#!/usr/bin/python3

import subprocess
import os
import sys
import datetime
from datetime import datetime as dt
import psycopg2
from psycopg2 import Error
import mdutils
import requests

from requests.packages.urllib3.exceptions import InsecureRequestWarning



# Function to execute query and write to markdown
def execute_query_and_write_to_md(query, headers, mdFile):
    try:
        connection = psycopg2.connect(**db_params)
        cursor = connection.cursor()
        cursor.execute(query,(host_id))
        rows = cursor.fetchall()
        data = []
        for row in rows:
            data.extend(list(row))
        mdFile.new_table(columns=len(headers), rows=len(data)//len(headers)+1, text=headers+data, text_align='left')
        cursor.close()
    except (Exception, Error) as error:
        print("Error while connecting to PostgreSQL", error)
    finally:
        if connection:
            connection.close()

# Function to fetch CPE and query API for CVE data
def fetch_cpe_and_query_api(mdFile):
    there_is_data = []
    details = []
    first_cve = True 

    try:
        connection = psycopg2.connect(**db_params)
    except (Exception, Error) as error:
        print("Error while connecting to PostgreSQL", error)
        sys.exit(3)
    
    cursor = connection.cursor()
    cursor.execute("SELECT cpe FROM service_version WHERE id_hosts="+str(host_id))
    print ("SELECT cpe FROM service_version WHERE id_hosts="+str(host_id))
    
    try:
        cpes = cursor.fetchall()
        for cpe_row in cpes:
            cpe = cpe_row[0]

            url = f"https://" + cve_search_hostname + ":" + cve_search_port + "/api/cvefor/" + cpe
            headers = {
                'X-Api-Key': 'key'
            }

            try:
                response = requests.get(url, headers=headers, verify=False)
            except (Exception, Error) as error:
                print("Error while fetching CVE from CVE_SEARCH", error)
                sys.exit(4)  

            cves = response.json()
            
            for cve in cves:
                try:
                    cvss = float(cve.get('cvss', 0))
                    if cvss >= 8.9:
                        # .lower used because this string must be in lowercase otherwise 
                        # the PDF links generated by pandoc/lualatex won't work
                        there_is_data.append([f"[{cve['id']}](#{cve['id'].lower()})", f"<span style='color:red;'>{cvss}</span>"])
                    if first_cve:
                        details.append(r"\newpage")
                        details.append("\n# Details\n")
                        first_cve = False
                    details.append(f"## [{cve.get('id', 'Unknown ID')}](https://www.opencve.io/cve/{cve.get('id', 'Unknown ID')})\n")
                    details.append(f" !--> CVE for {cpe}\n")
                    details.append(f"Summary: {cve.get('summary', 'No summary available')}\n")
                    details.append(f"\n\n\\textbf{{\\textcolor{{red}}{{CVSS: {cve.get('cvss', 'N/A')}}}}}\n\n")
                except Exception as e:
                    print(f"Error processing CVE data: {e}")
        cursor.close()
    
    except (Exception, Error) as error:
        print("Error while executing PostgreSQL query", error)
        sys.exit(3)        

    finally:
        if connection:
            connection.close()

    if there_is_data:
        headers = ["CVE", "Critical Severity"]
        mdFile.new_table(columns=2, rows=len(there_is_data)+1, text=headers+sum(there_is_data, []), text_align='left')
    
    return details


def cleanup_md(markdownFile):
    with open(markdownFile, "r") as f:
        lines = f.readlines()
    with open(markdownFile, "w") as f:
        for line in lines:
            if "newpage" not in line and "textbf" not in line:
                f.write(line)

# Function to update report view with the new report
def update_report():
    try:
        connection = psycopg2.connect(**db_params)
        cursor = connection.cursor()
        print("**************************************")
        print("update hosts set pdf='" + report_name + ".pdf', zip='" + report_name + ".zip' where id=" + str(host_id))
        print("**************************************")
        try:
            # Updating the table "hosts", not the view "report"
            cursor.execute("update hosts set report_date='" + str(dt.now()) + "', pdf='" + report_name + ".pdf', zip='" + report_name + ".zip' where id=" + str(host_id))
        except (Exception, Error) as error:
            print("Error while updating table hosts", error)
        finally:
            connection.commit()

        cursor.close()
    except (Exception, Error) as error:
        print("Error while connecting to PostgreSQL", error)
    finally:
        if connection:
            connection.close()

if len(sys.argv) != 2:
    print("Usage: python generate_report.py <host id>")
    sys.exit(1)


try:
    host_id=int(sys.argv[1])
except:
    print("Error: host id must be an integer")
    sys.exit(1)

# Disable:  InsecureRequestWarning: Unverified HTTPS request is being made to host 'localhost'
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# Set the correct hostnames and port depending in the current environment: wsl or Apache
postgres_hostname = "localhost"
cve_search_hostname = "localhost"
cve_search_port = "8443"
if os.uname()[1] == "apache":
    postgres_hostname = "postgres"
    cve_search_hostname = "cve_search"
    cve_search_port = "5000"


# Database parameters
db_params = {
    "host": postgres_hostname,
    "port": 5432,
    "database": "alvo_db",
    "user": "alvo",
    "password": "alvo"
}

# Necessary when running Flask through Apache: provide complete path name
# Base path on Apache container: /var/www/html/alvo/flask/back
# Generated file names are like: report_HHH_2024-07-02_1831.pdf, where HHH: host id left padded with 0
base_path = os.path.dirname(__file__)
report_full_name=base_path + "/reports/report_"+sys.argv[1].zfill(3)+"_"+str(datetime.datetime.now().strftime("%Y-%m-%d_%H%M"))
report_name="report_"+sys.argv[1].zfill(3)+"_"+str(datetime.datetime.now().strftime("%Y-%m-%d_%H%M"))

mdFile = mdutils.MdUtils(file_name=report_full_name + ".md", title='')

# Query for company and contact information
query1 = "SELECT company_name, first_name, last_name FROM report WHERE id="+str(host_id)

headers1 = ["Company Name", "First Name", "Last Name"]
execute_query_and_write_to_md(query1, headers1, mdFile)

# Query for host and service version information
query2 = "SELECT name, os_name, os_sp FROM hosts WHERE hosts.id="+str(host_id)
    
headers2 = ["Name", "OS Name", "OS SP"]
execute_query_and_write_to_md(query2, headers2, mdFile)


# Fetch CVE data and process it
details_section = fetch_cpe_and_query_api(mdFile)


# Finalize markdown file
mdFile.create_md_file()

# Append additional details to the markdown file
with open(report_full_name + '.md', 'a') as md_file:
    md_file.write("\n".join(details_section))

# Generate charts
subprocess.run([base_path + '/bar_chart.py', report_full_name + '.md'])
subprocess.run([base_path + '/pie_graphic.py', report_full_name + '.md'])

# Convert markdown to PDF and run additional scripts
subprocess.run(['pandoc', report_full_name + '.md', '-o', report_full_name + '.pdf', '--template=' + base_path + '/template.tex', '--pdf-engine=lualatex'])

# Create zip file. -j: do not store the path, just the file name
subprocess.run(['zip', '-j', report_full_name, report_full_name + '.md', report_full_name + '.pdf'])

# Update report view, column pdf with the report name
update_report()

# Cleanup Latex tags in Markdown file
print ("Report name: " + report_full_name)

cleanup_md(report_full_name + '.md')

# Execute : update report(report_date,pf,zip) values (datexxxx, report.pdf, report.zip)